package encryptionconfig

import (
	"encoding/base64"
	"sort"

	"k8s.io/apimachinery/pkg/runtime/schema"
	apiserverconfigv1 "k8s.io/apiserver/pkg/apis/config/v1"
	"k8s.io/klog"

	"github.com/openshift/cluster-kube-apiserver-operator/pkg/operator/encryption/crypto"
	"github.com/openshift/cluster-kube-apiserver-operator/pkg/operator/encryption/state"
)

var (
	emptyStaticIdentityKey = base64.StdEncoding.EncodeToString(crypto.NewIdentityKey())
)

// FromEncryptionState converts state to config.
func FromEncryptionState(encryptionState map[schema.GroupResource]state.GroupResourceState) *apiserverconfigv1.EncryptionConfiguration {
	resourceConfigs := make([]apiserverconfigv1.ResourceConfiguration, 0, len(encryptionState))

	for gr, grKeys := range encryptionState {
		resourceConfigs = append(resourceConfigs, apiserverconfigv1.ResourceConfiguration{
			Resources: []string{gr.String()}, // we are forced to lose data here because this API is broken
			Providers: secretsToProviders(grKeys),
		})
	}

	// make sure our output is stable
	sort.Slice(resourceConfigs, func(i, j int) bool {
		return resourceConfigs[i].Resources[0] < resourceConfigs[j].Resources[0] // each resource has its own keys
	})

	return &apiserverconfigv1.EncryptionConfiguration{Resources: resourceConfigs}
}

// ToEncryptionState converts config to state.
// Read keys contain a potential write key. Read keys are sorted, recent first.
func ToEncryptionState(c *apiserverconfigv1.EncryptionConfiguration) map[schema.GroupResource]state.GroupResourceState {
	if c == nil {
		return nil
	}

	ret := getGRsActualKeys(c)
	for gr, keys := range ret {
		if keys.HasWriteKey() {
			found := false
			for _, rk := range keys.ReadKeys {
				if state.EqualKeyAndEqualID(&rk, &keys.WriteKey) {
					found = true
					break
				}
			}
			if !found {
				keys.ReadKeys = append(keys.ReadKeys, keys.WriteKey)
			}
		}
		keys.ReadKeys = state.SortRecentFirst(keys.ReadKeys)
		ret[gr] = keys
	}
	return ret
}

// getGRsActualKeys parses the given encryptionConfig to determine the write and read keys per group resource.
// it assumes that the structure of the encryptionConfig matches the output generated by getResourceConfigs.
// each resource has a distinct configuration with zero or more key based providers and the identity provider.
// a special variant of the aesgcm provider is used to track the identity provider (since we need to keep the
// name of the key somewhere).  this is not an issue because aesgcm is not supported as a key provider since it
// is unsafe to use when you cannot control the number of writes (and we have no way to control apiserver writes).
func getGRsActualKeys(encryptionConfig *apiserverconfigv1.EncryptionConfiguration) map[schema.GroupResource]state.GroupResourceState {
	if encryptionConfig == nil {
		return nil
	}

	out := map[schema.GroupResource]state.GroupResourceState{}
	for _, resourceConfig := range encryptionConfig.Resources {
		// resources should be a single group resource and
		if len(resourceConfig.Resources) != 1 {
			klog.Infof("skipping invalid encryption config for resource %s", resourceConfig.Resources)
			continue // should never happen
		}

		grk := state.GroupResourceState{}

		// we know that this is safe because providers is non-empty
		// we need to track the last provider as it may be a fake provider that is holding the identity key info
		lastIndex := len(resourceConfig.Providers) - 1
		lastProvider := resourceConfig.Providers[lastIndex]
		var hasFakeIdentityProvider bool

		for i, provider := range resourceConfig.Providers {
			var key state.KeyState

			switch {
			case provider.AESCBC != nil && len(provider.AESCBC.Keys) == 1:
				key = state.KeyState{
					Key:  provider.AESCBC.Keys[0],
					Mode: state.AESCBC,
				}

			case provider.Secretbox != nil && len(provider.Secretbox.Keys) == 1:
				key = state.KeyState{
					Key:  provider.Secretbox.Keys[0],
					Mode: state.SecretBox,
				}

			case provider.Identity != nil:
				if i != 0 {
					continue // we do not want to add a key for this unless it is a write key
				}
				key = state.KeyState{
					Mode: state.Identity,
				}

			case i == lastIndex && provider.AESGCM != nil && len(provider.AESGCM.Keys) == 1 && provider.AESGCM.Keys[0].Secret == emptyStaticIdentityKey:
				hasFakeIdentityProvider = true
				continue // we handle the fake identity provider at the end based on if it is read or write key

			default:
				klog.Infof("skipping invalid provider index %d for resource %s", i, resourceConfig.Resources[0])
				continue // should never happen
			}

			if i == 0 {
				grk.WriteKey = key
			} else {
				grk.ReadKeys = append(grk.ReadKeys, key)
			}
		}

		// now we can explicitly handle the fake identity provider based on the key state
		switch {
		case grk.WriteKey.Mode == state.Identity && hasFakeIdentityProvider:
			grk.WriteKey.Key = lastProvider.AESGCM.Keys[0]
		case hasFakeIdentityProvider:
			grk.ReadKeys = append(grk.ReadKeys,
				state.KeyState{
					Key:  lastProvider.AESGCM.Keys[0],
					Mode: state.Identity,
				})
		}

		out[schema.ParseGroupResource(resourceConfig.Resources[0])] = grk
	}
	return out
}

// secretsToProviders maps the write and read secrets to the equivalent read and write keys.
// it primarily handles the conversion of KeyState to the appropriate provider config.
// the identity mode is transformed into a custom aesgcm provider that simply exists to
// curry the associated null key secret through the encryption state machine.
func secretsToProviders(desired state.GroupResourceState) []apiserverconfigv1.ProviderConfiguration {
	allKeys := desired.ReadKeys

	// Write key comes first. Filter it out in the tail of read keys.
	if desired.HasWriteKey() {
		allKeys = append([]state.KeyState{desired.WriteKey}, allKeys...)
		for i := 1; i < len(allKeys); i++ {
			if state.EqualKeyAndEqualID(&allKeys[i], &desired.WriteKey) {
				allKeys = append(allKeys[:i], allKeys[i+1:]...)
				break
			}
		}
	}

	providers := make([]apiserverconfigv1.ProviderConfiguration, 0, len(allKeys)+1) // one extra for identity

	// having identity as a key is problematic because IdentityConfiguration cannot store any data.
	// we need to be able to trace back to the secret so that it can move through the key state machine.
	// thus in this case we create a fake AES-GCM config and include that at the very end of our providers.
	// its null key will never be used to encrypt data but it will be able to move through the observed states.
	// we guarantee it is never used by making sure that the IdentityConfiguration is always ahead of it.
	var hasIdentityAsWriteKey, needsFakeIdentityProvider bool
	var fakeIdentityProvider apiserverconfigv1.ProviderConfiguration

	for i, key := range allKeys {
		switch key.Mode {
		case state.AESCBC:
			providers = append(providers, apiserverconfigv1.ProviderConfiguration{
				AESCBC: &apiserverconfigv1.AESConfiguration{
					Keys: []apiserverconfigv1.Key{key.Key},
				},
			})
		case state.SecretBox:
			providers = append(providers, apiserverconfigv1.ProviderConfiguration{
				Secretbox: &apiserverconfigv1.SecretboxConfiguration{
					Keys: []apiserverconfigv1.Key{key.Key},
				},
			})
		case state.Identity:
			// we can only track one fake identity provider
			// this is not an issue because all identity providers are conceptually equivalent
			// because they all lead to the same outcome (read and write unencrypted data)
			if needsFakeIdentityProvider {
				continue
			}
			needsFakeIdentityProvider = true
			hasIdentityAsWriteKey = i == 0
			fakeIdentityProvider = apiserverconfigv1.ProviderConfiguration{
				AESGCM: &apiserverconfigv1.AESConfiguration{
					Keys: []apiserverconfigv1.Key{key.Key},
				},
			}
		default:
			// this should never happen because our input should always be valid
			klog.Infof("skipping key %s as it has invalid mode %s", key.Key.Name, key.Mode)
		}
	}

	identityProvider := apiserverconfigv1.ProviderConfiguration{
		Identity: &apiserverconfigv1.IdentityConfiguration{},
	}

	if desired.HasWriteKey() && !hasIdentityAsWriteKey {
		// the common case is that we have a write key, identity comes last
		providers = append(providers, identityProvider)
	} else {
		// if we have no write key, identity comes first
		providers = append([]apiserverconfigv1.ProviderConfiguration{identityProvider}, providers...)
	}

	if needsFakeIdentityProvider {
		providers = append(providers, fakeIdentityProvider)
	}

	return providers
}
